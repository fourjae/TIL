#### 패키지 구조 개선

- 먼저 도메인을 만든다.(user, post, common 등)
    - 이후 각 내부에 controller(+ responseDto), domain(+ domainDto), service, infrastructure(+entity, repository) 생성

#### 의존성 역전하기

- interface를 생성한다. (interface)
    - 구현체를 생성한다.(Impl)

    - 구현체로 interface를 상속한다.    
        ```Java
        public class UserRepositoryImpl extends UserRepository {
        }
        ```
    
    - infrastructure에 있는 Repository의 경우 상위 모듈인 service에서 infrastructure에 의존하게 되므로 Service로 변경해 준다.

    - service 외부 연동을 담당하는 port 패키지 생성

        - service에서 사용할 Repository interface들을 생성한다.

    - service -> port interface를 통해 -> Repository 참조하도록 변경

    - RepositoryImpl에서 Repository(interface)를 @Override 하여 구현

    - 마찬가지로 외부 통신 또한 infrastructure에 @Override 하여 구현

- @Test 어노테이션만 사용하여 테스트 진행

Test (**CertificationServiceTest**)
```Java
@Test
public void 외부_연동_테스트(){
    // given - Service를 Bean에 등록하지 않음
    //         직접 구현하여 만든 Fake 객체를 생성자 주입을 통해 Service 객체 생성
    FakeMailSender fakeMailSender = new FakeMailSender();
    CertificationService certificationService = new CertificationService(fakeMailSender);

    // when
    certificationService.send("test@naver.com", 1, "test-naver-com");

    // then
    assertThat(fakeMailSender.email).isEqualTo("test@naver.com");
    assertThat(fakeMailSender.content).isEqualTo(content+"test-naver-com");



}
```
Mock (**FakeMailSender** implements MailSender)
```Java
@Override
public void send(String email, String title, String content){
    this.email = email;
    this.title = title;
    this.content = content;
}
```


### 도메인과 영속성 객체 구분하기

- Domain Entity, Jpa Entity를 분리한다.

- Repository에서 사용중인 JpaEntity -> DomainEntity로 변경

- RepositoryImpl에서 사용중인 JpaEntity -> DomainEntity로 변경

- RepositoryImpl에서 JpaEntity -> DomainEntity로 바꿔주는 메서드 생성

    - JpaEntity에 DomainEntity 객체를 반환해주는 toModel() builder 객체 생성

    - JpaEntity에 JpaEntity 객체를 반환해주는 fromModel() 객체 생성

        - (Domain은 Infrastructure Layer를 모르는 것이 좋음)

    - userJpaRepository.findById(id).map(JpaEntiy::toModel);

- Service에서 JpaEntity -> DomainEntity로 변경

    - DomainEntity가 책임을 가지고 있어야 할 경우 객체로 부터 받은 값을 DomainEntity로 변경해주는 from builder 객체 생성

- JpaRepository.findById() 이후 DomainEntity로 값 변환시 jpa가 변경된 엔티티를 감지하고 수정하지 못하여 JpaRpoeisotry.save 필요함

- Controller에서 JpaEntity -> DomainEntity로 변경

- Controller가 들고있는 부자연스러운 DomainEntity -> Response로 변환해주는 객체는 응답객체에 builder() 객체 생성하여 위임

### 도메인에 테스트 추가하기


Mock (**FakeMailSender** implements MailSender)
```Java
@Test
public class PostCreate() {
    // given
    PostCreate postCreate = PostCreate.builder()
        .writeId(1)
        .content("helloWorld")
        .build();

    User user = User.Builder()
        .email("test@naver.com")
        .nickname("tester")
        .address("Seoul Gangnam")
        .status(UserStatus.PENDING)
        .certificationCode("certification-Code-For-Test")
        .build();

    // when
    Post post = post.from(user, postCreate);

    // then
    assertThat(post.getContent()).isEqualTo("helloWorld");
    assertThat(post.certificationCode()).isEqualTo("certification-Code-For-Test");
}
```

UUID.randomUUID().toString() 값을 테스트 하려면?

- UuIdHolder interface를 생성한다. (의존성 역전)

- infrastructure에 구현체를 만든다.  

    -   ```Java
        public class SystemUuidHolder implements UuidHolder {

            @Override
            public String random(){
                return UUID.randomUUID().toString();   
            }
        }
        ```
- 이제 외부에서 주입받도록 한다.

    -   ```Java
        public static User from(UuidHolder uuidHolder){
            return User.builder().
                .certificationCode(uuidHolder.random())
                .build();
        }
        ```

- 마찬가지로 TestUuidHolder 클래스를 생성하여 UuIdHolder를 구현한다.

    -   ```Java
            @RequiredArgsConstructor
            public class TestUuidHolder implements UuidHolder {
                private final String uuid;

                @Override
                public String random() {
                    return uuid;
                }

            }
        ```

### 서비스를 소형테스트로 만들기

- Service에서 사용할 (Repository를 구현한) FakeRepository 클래스 생성
    ```Java
    public class FakeRepository implements JpaRepository {
        // 자동으로 증가하는 값은 AtomicLong으로 관리
        private final AtomicLong autoGeneratedId = new AtomicLong(0);
        // Data를 저장하는 Collection 생성
        private final List<User> data = new ArrayList<>();

            @Override
            public User save(User user) {
                if(user.getId() == null || user.getId() == 0 || ){
                    User newUser = User.builder()
                        .id(autoGeneratedId.incrementAndGet())
                        .email(user.getEmail())
                        //build 파라미터 생략
                        .build())
                    data.add(newUser);
                    return newUser;
                } else {
                    data.removeIf(item -> Objects.equals(item.getId() == user.getId())));
                    data.add(user);
                    return user;
                }
            @Override
            public Optional<User> findById(long id) {
                return data.stream().filter(item -> item.getId().equals(id)).findAny();
            }

            @Override
            public Optional<User> findByIdAndStatus(long id, UserStatus userStatus){
                return data.stream().filter(item -> item.getId().equals(id) && item.getStatus() == userStatus).findAny();
            }
        }
    }
    ```

- 소형 테스트를 만들자.

- UserService에 @Builder 어노테이션을 만들어주면 아래와 같이 Test에 사용 가능
```Java

public class UserServiceTest {

    private UserService userService;

    @BeforeEach
    void init() {
        FakeMailSender fakeMailSender = new FakeMailSender();
        FakeUserRepository fakeUserRepository = new FakeUserRepository();
        this.userService = UserService.builder()
            .uuidHolder(new TestUuidHolder("certification-Code-For-Test"))
            .clockHolder(new TestClockHolder(1673495112225L))
            .userRepository(fakeUserRepository)
            .certificationService()
            .build();
        //테스트용 유저 데이터 생성
        fakeUserRepository.save(User.builder()
                                    .//생략
                                    .build());
    }

}

```

- Service가 다른 Service를 의존하고 있을 경우

    - 해당 Service 대신 Service가 호출하는 Repository에 메서드를 구현하자.
    
    - 이후 Service 대신 Repository를 주입

    - service.getById() -> repository.getById(); 변경

- 사용하지도 않는데 의존하고 있으면 또 작성하고 구현해야 해서 귀찮다.

    - 테스트 짜는게 귀찮다고 느껴진다면 의존성을 줄여보자

- ClockHolder와 같이 SystemUTC 저장 값들은 의존성을 바깥으로 빼내자

    - return 할 때 값을 만들지 말고 외부 파라미터로 부터 주입 받을 수 있게 하자


h2나 mockito 없이 서비스 테스트를 소형 테스트로 만드는 작업을 할 수 있었다.

자바가 아니어도 테스트 라이브러리 없이 테스트가 가능하게 될 것이다.

이렇게 변경할 수 있었던 이유는 의존성 역전, 의존성 주입을 통해 설계가 개선되었기 떄문이다.
