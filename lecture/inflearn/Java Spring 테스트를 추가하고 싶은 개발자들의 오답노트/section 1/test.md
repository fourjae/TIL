Java 12버전부터 스위치에 람다 표기가 가능하다.

``` Java
long answer = switch (operator) {
    case "+" -> num1 + num2;
}

```

VO?
ValueObject 변수들은 값이 항상 유효하다.

TDD란?

RED 1. 깨지는 테스트를 먼저 작성한다. 실제 서비스는 Exception을 던진다.

GREEN 2. 깨지는 테스트를 성공시킨다. 실제 서비스를 구현한다.

BLUE 3. 리팩토링한다.

RED

TDD를 통해 interface를 생각하지 않고 구현체부터 만드는 실수를 안할 수 있다.
테스트를 작성해야 하기 때문이다.

interface에 집중한다는 것은 객체 지향의 핵심 원리 중 하나인 행동에 집중할 수 있다.

책임-주도 설계의 핵심 과정인 What/Who 사이클을 고민하게 도와준다.

TDD를 통해 알 수 있는 것은 테스트와 아키텍처가 비례한다는 것
(신규 개발 이후 전체 테스트를 돌려보면 문제가 생겼는지 알 수 있음)

BLUE
2줄짜리 서비스를 위해 무거운 60줄 테스트를 만드는게 맞는가? 
findById()와 같은 JPA 메서드는 JPA 구현체가 알아서 잘 테스트 했을 것이다. (Spring boot + H2 까지 사용하므로 테스트가 무겁다.)
행동에 집중하는 것이라면 중요한 로직에 우선적으로 테스트를 만드는 것이 낫다.


테스트를 작성하다보면 
시간이 오래걸리는 테스트, 병렬 문제, 테스트가 불가능한 코드 등이 있을 수 있다. 
테스트가 불가능하다고 Mock 라이브러리를 이용해 강제로 테스트를 넣기보다 테스트가 가능하도록 개선하고 설계를 변경해야 한다.

---

테스트는 왜 필요한가?  

1. Regression, 배포 이후 버그가 발생할 수 있는 문제에 부딪힐 수 있어 생산성이 저하됨
- 팀원들의 생산성 향상에 필요

2. 테스트를 작성하면 좋은 아키텍처를 설계할 수 있다. 
- TEST의 회귀 버그 방지와 통해 SOLID의 좋은 설계를 통해 좋은 아키텍처를 만든다.

SOLID 원칙

단일 책임 원칙 (Single responsibility principle)
한 클래스는 하나의 책임만 가져야 한다.

개방-폐쇄 원칙 (Open/closed principle)
소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.

리스코프 치환 원칙 (Liskov substitution principle)
“프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 슈퍼 -> 하위 타입의 인스턴스로 바꿀 수 있어야 한다.” 계약에 의한 설계를 참고하라.

인터페이스 분리 원칙 (Interface segregation principle)
클라이언트는 자신이 이용하지 않는 메서드에 의존하지 않아야 한다. 범용 인터페이스 하나 보다 특정 클라이언트들을 위한 인터페이스 여러개가 낫다.

의존관계 역전 원칙 (Dependency inversion principle)
프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.”[4] 의존성 주입은 이 원칙을 따르는 방법 중 하나다.


테스트의 3분류

API(대형) Test - E2E 5%
- 멀티 서버, E2E 테스트 가능

통합(중형) 테스트 - INTEGRATION 15%
- 단일 서버, 멀티 프로세스, 멀티 스레드, db 테스트 사용 가능

단위(소형) 테스트 - UNIT 80%
- 단일 서버, 단일 프로세스, 단일 스레드, 디스크 I/O 사용 X, Blocking call 허용 X