Java 12버전부터 스위치에 람다 표기가 가능하다.

``` Java
long answer = switch (operator) {
    case "+" -> num1 + num2;
}

```

VO?
ValueObject 변수들은 값이 항상 유효하다.

TDD란?

RED 1. 깨지는 테스트를 먼저 작성한다. 실제 서비스는 Exception을 던진다.

GREEN 2. 깨지는 테스트를 성공시킨다. 실제 서비스를 구현한다.

BLUE 3. 리팩토링한다.

RED

TDD를 통해 interface를 생각하지 않고 구현체부터 만드는 실수를 안할 수 있다.
테스트를 작성해야 하기 때문이다.

interface에 집중한다는 것은 객체 지향의 핵심 원리 중 하나인 행동에 집중할 수 있다.

책임-주도 설계의 핵심 과정인 What/Who 사이클을 고민하게 도와준다.

TDD를 통해 알 수 있는 것은 테스트와 아키텍처가 비례한다는 것
(신규 개발 이후 전체 테스트를 돌려보면 문제가 생겼는지 알 수 있음)

BLUE
2줄짜리 서비스를 위해 무거운 60줄 테스트를 만드는게 맞는가? 
findById()와 같은 JPA 메서드는 JPA 구현체가 알아서 잘 테스트 했을 것이다. (Spring boot + H2 까지 사용하므로 테스트가 무겁다.)
행동에 집중하는 것이라면 중요한 로직에 우선적으로 테스트를 만드는 것이 낫다.


테스트를 작성하다보면 
시간이 오래걸리는 테스트, 병렬 문제, 테스트가 불가능한 코드 등이 있을 수 있다. 
테스트가 불가능하다고 Mock 라이브러리를 이용해 강제로 테스트를 넣기보다 테스트가 가능하도록 개선하고 설계를 변경해야 한다.

---

테스트는 왜 필요한가?  

1. Regression, 배포 이후 버그가 발생할 수 있는 문제에 부딪힐 수 있어 생산성이 저하됨
- 팀원들의 생산성 향상에 필요

2. 테스트를 작성하면 좋은 아키텍처를 설계할 수 있다. 
- TEST의 회귀 버그 방지와 통해 SOLID의 좋은 설계를 통해 좋은 아키텍처를 만든다.

SOLID 원칙

단일 책임 원칙 (Single responsibility principle)
한 클래스는 하나의 책임만 가져야 한다.

개방-폐쇄 원칙 (Open/closed principle)
소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.

리스코프 치환 원칙 (Liskov substitution principle)
“프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 슈퍼 -> 하위 타입의 인스턴스로 바꿀 수 있어야 한다.” 계약에 의한 설계를 참고하라.

인터페이스 분리 원칙 (Interface segregation principle)
클라이언트는 자신이 이용하지 않는 메서드에 의존하지 않아야 한다. 범용 인터페이스 하나 보다 특정 클라이언트들을 위한 인터페이스 여러개가 낫다.

의존관계 역전 원칙 (Dependency inversion principle)
프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.”[4] 의존성 주입은 이 원칙을 따르는 방법 중 하나다.


테스트의 3분류

API(대형) Test - E2E 5%
- 멀티 서버, E2E 테스트 가능

통합(중형) 테스트 - INTEGRATION 15%
- 단일 서버, 멀티 프로세스, 멀티 스레드, db 테스트 사용 가능

단위(소형) 테스트 - UNIT 80%
- 단일 서버, 단일 프로세스, 단일 스레드, 디스크 I/O 사용 X, Blocking call 허용 X

---

SUT - System under test (테스트 하려는 대상)

BDD - Behaviour driven development (행동 주도 개발)
- given(상황) , when (행동), then(결과) 방식을 권유한다.

Interaction test (상호 작용 테스트)
- 내부 구현이 어떻게 구현되었는지 테스트 한다. 캡슐화에 위배된다.

test fixture (테스트에 필요한 자원을 생성하는 것)
- 코드 중복이 심하게 발생하지 않는한 가급적 사용 

비욘세 규칙
- 유지하고 싶은 상태가 있으면 전부 테스트로 작성한다.

Test Double (테스트 대역, 가짜 객체)
- Dummy : 아무런 동작도 하지 않는 객체
- Fix : 자체적인 로직을 가진 가짜 객체
- Stub : 미리 준비된 값을 출력하는 객체
- Mock : 메소드 호출을 확인하기 위한 객체
- Spy : 메소드 호출을 전부 기록했다가 나중에 확인하는 객체

---

Testability

의존성이란? 하나의 객체가 다른 객체의 기능을 사용하는 상태

디자인 패턴과 설계들은 객체, 시스템간의 협력에 대해 의존성을 약화시킬 수 있는지 고민한 결과물이라고 볼 수 있다.

의존성 역전이란? "의존하는 화살표의 방향을 바꾸는 테크닉"

- 인터페이스와 구현을 분리한 것
    - 상위 모듈 -> 하위 모듈 의존 X
    - 상위 모듈 -> INTERFACE (추상화) <- 하위모듈 의존 O
    - 세부 사항 -> INTERFACE (추상화) 의존 O
    - 구체적인 요소 (모듈) -> 추상화된 선언 (정책)

테스트를 잘 하려면 의존성 주입, 의존성 역전이 중요하다.

외부에서 login 함수를 호출 할 때, 내부에서 Clock 객체를 사용하면 Clock에 의존적인 테스트가 있다.
- 의존성 주입을 통해 Clock 객체를 외부에서 주입 받을 수 있도록 변경한다. (의존성 주입)
- ClockHolder라는 Interface를 만들어 Clock -> ClockHolder <- login 과 같이 의존하게 한다. (의존성 역전)
- 추상화에 의존하고 다형성의 원리를 이용하여 테스트, 배포 환경을 분리할 수 있게 되었다.
- 그런 의미에서 Port-Adapter 패턴이라고도 불린다.

테스트 가능성 (Testability)

"얼마나 쉽게 input을 변경하고, output을 쉽게 검증할 수 있는가?"
호출자는 모르는 입력이 존재하면 안된다. (캡슐화 위배)

하드코딩이 되어 있거나, 외부 시스템과 연동 되어 있는 경우 Service를 테스트 하기 힘들다.

---

- 빌더 패턴
    - 객체 생성이 다양해지는 문제를 해결하기 위해 마련된 유동적인 해결책
        - 생성자가 지나치게 많아질 수 있는 문제를 해결
        - 파라미터가 여러개가 되면 유지보수 되기도 어려움
        - 빌더 패턴을 통해 테스트에 필요한 파라미터만 지정함으로써 가독성을 늘려줌

    - 빌더 패턴은 테스트 객체의 구조적인 변화로부터 테스트를 다시 한번 보호한다.

- 엔티티
    - 도메인 엔티티
        - 비즈니스에서 어떤 문제를 해결하기 위해 만들어진 모델
    
        - 식별 가능, 생명 주기 갖고 있음
    
        - JPA와 크게 관련은 없음
    
    - DB 엔티티
    
        - 데이터베이스의 유/무형 객체를 표현하기 위해 사용되는 의미
    
    - 영속성 객체
    
        - ORM, ODM

도메인 엔티티와 영속성 객체는 구분되어야 하나 이는 정답이 없는 문제다.

도메인에 JPA Entity가 붙는 순간 RDB에 의존하게 된다.

JPA는 RDB에서 파생된 단어를 사용하기 때문에 DocumentDB(MongoDB) 에서는 적합 하지 않다. (ex ORM -> ODM)

테스트와 관련하여 조언

- private 접근 제어자는 테스트 하지 않아도 된다.
    
    - http://shoulditestprivatemethods.com
    
    - 책임이 제대로 할당된게 아니다. 책임을 위임해서 public으로 만들어라

- final 메서드를 stub 해야 한다면 설계가 잘못되었다.
    
    - 이는 더이상 변경하지 않을 선언이기 때문이다.

    - 의존성 역전(구현체가 final 메서드에 의존)을 통해 해결해야 한다.

- DRY 대신 DMAP

- 논리를 넣지 말자.
